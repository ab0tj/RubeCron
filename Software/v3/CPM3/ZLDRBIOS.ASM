
;	CP/M 3.0 LOADER BIOS FOR THE RubeCron Z80 board (banked)
;
;		AB0TJ, 2021
;
;		ORIGINALLY WRITTEN BY 	JOHN MONAHAN	(11/27/2009)
;

BELL	EQU	07H
CR	EQU	0DH
LF	EQU	0AH
NBYTES  EQU	512
SD$CAP EQU	0FFFFH		;SD capacity flag, left in memory by initial bootloader

				
MMU$PG0	EQU 040H
MMU$PG1	EQU 041H
MMU$PG2 EQU 042H
MMU$PG3 EQU 043H
MMU$EN	EQU 048H

UART$BASE	EQU 020H
UART$SRA    EQU UART$BASE + 1	
UART$FIFOA	EQU UART$BASE + 3

MID$BASE	EQU 010h
MID$FMB	    EQU MID$BASE + 01h
MID$CS      EQU MID$BASE + 0Ah
MID$ST      EQU MID$BASE + 0Eh

LED$SEC 	EQU 50h		; seconds display
LED$MIN     EQU 51h		; MINutes display
LED$HRS 	EQU 52h		; hours display
LED$DAY 	EQU 53h		; DAY display

	; INCLUDE CP/M 3.0 DISK DEFINITION MACROS:
	MACLIB	CPM3
	MACLIB	Z80

;	CODE BEGINS HERE:	

	JMP	BOOT			;INITIAL ENTRY ON COLD START
	JMP	WBOOT			;REENTRY ON PROGRAM EXIT, WARM START
	JMP	CONST			;RETURN CONSOLE INPUT STATUS
	JMP	CONIN			;RETURN CONSOLE INPUT CHARACTER
	JMP	CONOUT			;SEND CONSOLE OUTPUT CHARACTER
	JMP	LIST			;SEND LIST OUTPUT CHARACTER
	JMP	AUXOUT			;SEND AUXILLIARY OUTPUT CHARACTER
	JMP	AUXIN			;RETURN AUXILLIARY INPUT CHARACTER
	JMP	HOME			;SET DISKS TO LOGICAL HOME
	JMP	SELDSK			;SELECT DISK DRIVE, RETURN DISK PARAMETER INFO
	JMP	SETTRK			;SET DISK TRACK
	JMP	SETSEC			;SET DISK SECTOR
	JMP	SETDMA			;SET DISK I/O MEMORY ADDRESS
	JMP	READ			;<----------- READ PHYSICAL BLOCK(S)
	JMP	FWRITEA			;WRITE PHYSICAL BLOCK(S)
	JMP	LISTST			;RETURN LIST DEVICE STATUS
	JMP	SECTRN			;TRANSLATE LOGICAL TO PHYSICAL SECTOR
	JMP	CONOST			;RETURN CONSOLE OUTPUT STATUS
	JMP	AUXIST			;RETURN AUXILLIARY INPUT STATUS
	JMP	AUXOST			;RETURN AUXILLIARY OUTPUT STATUS
	JMP	DEVTBL			;RETURN ADDRESS OF DEVICE DEFINITION TABLE
	JMP	?CINIT			;CHANGE BAUD RATE OF DEVICE
	JMP	GETDRV			;RETURN ADDRESS OF DISK DRIVE TABLE
	JMP	MULTIO			;SET MULTIPLE RECORD COUNT FOR DISK I/O
	JMP	FLUSH			;FLUSH BIOS MAINTAINED DISK CACHING
	JMP	?MOVE			;BLOCK MOVE MEMORY TO MEMORY
	JMP	?TIME			;SIGNAL TIME AND DATE OPERATION
	JMP	BNKSEL			;SEL BANK FOR CODE EXECUTION AND DEFAULT DMA
	JMP	SETBNK			;SELECT DIFFERENT BANK FOR DISK I/O DMA OPS.
	JMP	?XMOVE			;SET SOURCE AND DEST. BANKS FOR ONE OPERATION
	JMP	0			;RESERVED FOR FUTURE EXPANSION
	JMP	0			;     DITTO
	JMP	0			;     DITTO


CONST:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

LISTST:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

AUXIST:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

AUXOST:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

FLUSH:	XRA	A			; ROUTINE HAS NO FUNCTION IN LOADER BIOS:
	RET				; RETURN A FALSE STATUS

LIST:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

AUXOUT:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

DEVTBL:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

?CINIT:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

MULTIO:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

?TIME:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

BNKSEL:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

SETBNK:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

?XMOVE:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

CONIN:	MVI   A,'Z'-40H			; ROUTINE HAS NO FUNCTION IN LOADER BIOS:
	RET

AUXIN:	MVI   A,'Z'-40H			; ROUTINE HAS NO FUNCTION IN LOADER BIOS:
	RET

CONOUT:	CALL	CONOST			; ROUTINE OUTPUTS A CHARACTER IN [C] TO THE CONSOLE:
	JRZ	CONOUT
	MOV	A,C
	OUT	UART$FIFOA
	RET	

CONOST:	IN	UART$SRA			; RETURN CONSOLE OUTPUT STATUS:
	ANI	04H
	RZ				;0 IF NOT READY
	XRA	A
	DCR	A
	RET

?MOVE:	XCHG
	LDIR
	XCHG
	RET

SELDSK:	LXI	H,DPH0			; RETURN DPH ADDRESS FOR DRIVE A:
	RET

HOME:	LXI	B,0			; HOME SELECTED DRIVE -- TREAT AS SETTRK(0):

SETTRK:	SBCD	@TRK			; ROUTINE SETS TRACK TO ACCESS ON NEXT READ
	RET
	
SETSEC:	SBCD	@SECT			; ROUTINE SETS SECTOR TO ACCESS ON NEXT READ
	RET

SETDMA:	SBCD	@DMA			; ROUTINE SETS DISK MEMORY ADDRESS FOR READ
	RET
					;Arrive here with [BC] = Sec #,  [DE] Translation table address.
SECTRN:	
	MOV H,B
	MOV L,C 		; null sector skew
	RET

GETDRV:	LXI	H,@DTBL			; RETURN ADDRESS OF DISK DRIVE TABLE:
	RET

FINITA:	RET				; ROUTINE HAS NO FUNCTION IN LOADER BIOS:

FLOGA:	RET				; DOES NOT SEEM TO BE USED IN LOADER BIOS

FWRITEA:XRA	A			; RETURN GOOD RESULT CODE
	RET


WBOOT:	RET				; WARM BOOT IS NOT USED IN LOADER BIOS

	;;;;; BOOT
					; ROUTINE DOES COLD BOOT INITIALIZATION 
					; (Used here to setup RAM banks and remove EPROM)

BOOT:
	XRA A
	OUT LED$DAY
	OUT LED$HRS
	OUT LED$MIN
	OUT LED$SEC
	;IF BANKED, we need to setup memory mapping
	;RET
	;LDA	BANK$FLAG		;(RAM location 46H), Z if a non-banked CPMLDR file is to be run
	;ORA	A			;NZ for a banked CPMLDR (the CPMLDR does not use this byte)
	;RZ				;Skip banking stuff if non-banked
					;Note cannot seem to get CONOUT calls to work at this point
					;seem things/stack? are not yet valid with CPM.
;======================================================================================

	; LETS RELOCATE OUR MEMORY IMAGE UP TO THE 10000H-17FFFH MEMORY
	; REGION FOR EXECUTION -- CP/M 3.0 BANK 0 WILL BE THAT EXTENDED
	; ADDRESS REGION AND THE TPA WILL BE PART OF THE NORMAL LOWER 64K

	MVI	A,24H			;<--- BIT 5 IS TO SELECT RAM INSTEAD OF ROM
	OUT	MMU$PG1			;THIS RELOCATES MMU PAGE 1 TO 10000H-13FFFH
	LXI	B,2000H			;WE WILL MOVE 8K BYTES
	LXI	H,0				;STARTING FROM 00000H
	LXI	D,4000H			; UP TO 10000H
	LDIR				;Z-80 BLOCK MOVE
	MVI	A,24H
	OUT	MMU$PG0			;SWITCH OURSELVES IN TO THAT WINDOW.
						;The CPMLOADER is now actully at 10100H upwards.
	INR A				;AND MAKE THE UPPER WINDOW CONTIGUOUS SO WE HAVE 32K STARTING 
	OUT	MMU$PG1			;AT 10000H in RAM (i.e 10000H-17FFFH).
	RET
;======================================================================================


;	READ A SECTOR			;READ A SECTOR

READ:	
	SSPD	OLDSTACK		;See bottom of this module
	LXI	SP,NEWSTACK
	LHLD @TRK
	LDED @SECT
	LXI B,0
    DAD H	; Track*2
    DAD H	; *4
	DAD H	; *8
	DAD H	; *16
	DAD H	; *32 (sectors per track)
	DAD D	; add sector number (0-based)
	XCHG
	; don't forget to adjust for drive number in final BIOS
	; will need 32-bit math for that if going past 32MB
	CALL SD$GETBLOCK
	LSPD	OLDSTACK		;VIP!	
	RET


;============== SUPPORT ROUTINES FOR HARDWARE =================================
;
CSL MACRO
	MVI A,0FEH
	OUT MID$CS
	ENDM

CSH MACRO
	MVI A,0FFH
	OUT MID$CS
	ENDM

SD$GETBLOCK:	; read a block specified by bcde (LBA) into memory
	LDA SD$CAP  	; we need to shift the block value left by 9 if card is not LBA
    ANA 1
    CZ LSHIFT9				; Adjust for byte address if necessary

	CSL
    MVI A,17            	; CMD17: read block
    CALL SD$CMD
SD$GETBLOCK$WAIT:      		; wait for start token
    CALL MID$RX
    CPI 0FEh
    JZ RX				  	; start token
    CPI 0FFh
    JZ SD$GETBLOCK$WAIT  	; still waiting
    JMP SD$GETBLOCK$ERROR	; error
RX:
	LHLD @DMA				;Get DMA address
	LXI D, 512				;Bytes/sector for this disk format (128,256,512 or 1024)
RX$1:
    MOV A,D
    ANA A
    JNZ RX$2
    MOV A,E
    ANA A
    JZ RX$DONE
RX$2:
    CALL MID$RX
    MOV M,A
    INX H
    DCX D
    JMP RX$1
RX$DONE:
	CALL MID$RX
	CALL MID$RX			; get CRC bytes and discard
SD$GETBLOCK$DONE:
    CSH
	XRA A				; 0 = no error
    RET

SD$GETBLOCK$ERROR:
    CSH
	MVI A,1				; 1 = error
	RET

SD$DUMMY:
    CALL MID$RX
    DCR B
    JNZ SD$DUMMY     ; send dummy byte
    RET

SD$CMD:
    MOV L,A
    CALL MID$RX			; give the card time to do things
    MOV A,L
    ORI 40H
    CALL MID$XFER        ; command | 0x40
    MOV A,B
    CALL MID$XFER        ; arg>>24
    MOV A,C
    CALL MID$XFER        ; arg>>16
    MOV A,D
    CALL MID$XFER        ; arg>>8
    MOV A,E
    CALL MID$XFER        ; arg
    MOV A,H
    CALL MID$XFER        ; checksum
SD$CMD$WAIT:
    CALL MID$RX
    CPI 0FFh
    JZ SD$CMD$WAIT   ; loop until we get reply
    MOV E,A
    RET

LSHIFT9:    ; Multiply bcde by 512
    MOV B,C ; shift left by 8
    MOV C,D
    MOV D,E
    MVI E,0
    SLAR D  ; shift left by one
    RALR C
    RALR B
    RET

; MID functions
MID$RX:			; Enter here if only receiving a byte
	MVI A,0FFH
MID$XFER:		; Enter here to send byte in A
    OUT MID$FMB
MID$XFER$WAIT:
    IN MID$ST
    ANI 80H
    JZ MID$XFER$WAIT
    IN MID$FMB
    RET

;Print the acccumulator value on CRT in HEX-ASCII
;PACC:	PUSH	PSW
;	PUSH	B

;	PUSH	PSW
;	RRC
;	RRC
;	RRC
;	RRC
;	CALL	ZCONV
;	POP	PSW
;	CALL	ZCONV
;	POP	B
;	POP	PSW
;	RET

;ZCONV:	ANI	0FH		;HEX to ASCII
;	ADI	90H
;	DAA
;	ACI	40H
;	DAA
;	MOV	C,A
;	CALL	CONOUT
;	RET

;SPECIAL$PMSG:				;Cannot use @PMSG in LOADERBIOS
;	MOV	A,M
;	INX	H
;	ANA A
;	RZ	
;	MOV	C,A
;	CALL	CONOUT			;Hardware send to consol
;	JMP	SPECIAL$PMSG

@TRK:		DW	0		;2 BYTES FOR NEXT TRACK TO READ OR WRITE
@DMA:		DW	0		;2 BYTES FOR NEXT DMA ADDRESS
@SECT		DW	0		;2 BYTES FOR SECTOR
@SECTOR$BYTE$COUNT DW	0		;2 BYTES FOR Bytes/Sector

OLDSTACK:DW	0
	 DS	40
NEWSTACK:DW	0

               	; DISK DRIVE TABLE:
@DTBL:	DW	DPH0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0


DPH0:	DPH	0,DISK$DPB

	; MAKE SURE DPB'S ARE IN COMMON MEMORY:
					;IF	BANKED			
	CSEG
	
DISK$DPB:
	DPB	512,32,512,2048,1024,1,8000H	; 512b/sec, 32 SPT, 512 tracks, 2k alloc, 1k dir entries, 1 sys trk, non-removable = 8MB

	DB	'<----- END OF LOADER BIOS  >' ;Useful for debugging

